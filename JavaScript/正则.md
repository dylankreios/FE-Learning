## 模式和修饰符

两种语法：

```JavaScript
// 构造函数创建，支持变量
regexp = new RegExp("pattern", "gmi");

// 斜杠创建，不支持变量
regexp = /pattern/gmi;
```

修饰符：

|     `i`      |       `g`        |   `m`    |      `u`       |   `y`    |
| :----------: | :--------------: | :------: | :------------: | :------: |
| 不区分大小写 | 查找所有的匹配项 | 多行模式 | `unicode` 支持 | 粘滞模式 |

如果不使用**修饰符**和**特殊标志**，正则表达式的搜索等同于子字符串查找

`str.search(regexp)` 方法返回的是找到的匹配项的索引位置，如果没找到则返回 `-1`

```JavaScript
"i love you".search(/love/); // 2
```

## 字符类

| `\d` |  `\D`  |           `\s`           |   `\S`    |            `\w`            |   `\W`    |                        `.`                        |
| :--: | :----: | :----------------------: | :-------: | :------------------------: | :-------: | :-----------------------------------------------: |
| 数字 | 非数字 | 空格符号，制表符，换行符 | 除了 `\s` | 拉丁字母，数字，下划线 `_` | 除了 `\w` | 除换行符 `\n` 之外的任何字符，带`s`标志为任何字符 |

`str.match(regexp)` 方法返回的是找到的匹配项，如果没找到则返回 `null`

```JavaScript
"Is there CSS4?".match(/CSS\d/); // CSS4
```

## `Unicode`：`u`

修饰符 `u` 在正则表达式中提供对 `Unicode` 的支持

这意味着两件事：

1. `4` 个字节长的字符被以正确的方式处理：被看成单个的字符，而不是 `2` 个 `2` 字节长的字符
2. `Unicode` 属性可以被用于查找中 `\p{...}`

有了 `unicode` 属性我们可以查找给定语言中的词，特殊字符（引用，货币）等等

## 锚点：`^$`

插入符号 `^` 和美元符号 `$` 在正则表达式中被称为锚点

插入符号 `^` 匹配文本开头，美元符号 `$` 匹配文本末尾

例子

```JavaScript
let str1 = "Mary had a little lamb";
let str2 = "it's fleece was white as snow";

console.log( /^Mary/.test(str1) ); // true
console.log( /snow$/.test(str1) ); // true
```

但是这不能体现正则的优势

**测试完全匹配**
这两个锚点 `^...$` 放在一起常常被用于测试一个字符串是否完全匹配一个模式

```JavaScript
let goodInput = "12:34";
let badInput = "12:345";

let regexp = /^\d\d:\d\d$/;
console.log( regexp.test(goodInput) ); // true
console.log( regexp.test(badInput) ); // false
```

整个字符串必须准确地符合这一个格式。如果其中有任何偏差或者额外的字符，结果将为 `false`

注意：

锚点具有**零宽度**，锚点 `^` 和 `$` 属于测试。它们的宽度为零，它们并不匹配一个具体的字符，而是让正则引擎测试所表示的**条件**

## 多行模式：`m`

通过 `/.../m` 可以开启多行模式。这仅仅会影响 `^` 和 `$` 锚符的行为

**行的开头 `^`**

多行文本对每一行匹配，正则表达式 `/^\d+/gm` 将匹配每一行的开头数字

```JavaScript
let str = `1st place: Winnie
2nd place: Piglet
33rd place: Eeyore`;

alert( str.match(/^\d+/gm) ); // 1, 2, 33
alert( str.match(/^\d+/g) ); // 1
```

**行的结尾 `$`**

类似的

```JavaScript
let str = `1st place: Winnie
2nd place: Piglet
33rd place: Eeyore`;

alert( str.match(/\w+$/gm) ); // Winnie, Piglet, Eeyore
```

**锚符 `^$` 对比 `\n`**

寻找新的一行除了锚点也可以使用 `\n`，但是换行符 `\n` 不是零宽度，会加入到匹配结果中

```JavaScript
let str = `1st place: Winnie
2nd place: Piglet
33rd place: Eeyore`;

alert( str.match(/\w+\n/gim) ); // Winnie\n,Piglet\n
```

为什么最后一行没被匹配？因为换行符 `\n` 不会匹配字符串结尾

## 词边界：`\b`

和锚点一样，词边界是零宽度，检查字符串中的位置是否是词边界

三种不同的位置可作为词边界

- 在字符串开头，第一个字符是单词字符 `\w`
- 在字符串中的两个字符之间，其中一个是单词字符 `\w`，另一个不是
- 在字符串末尾，最后一个字符是单词字符 `\w`

例如：

```JavaScript
alert( "Hello, Java!".match(/\bJava\b/) ); // Java
alert( "Hello, JavaScript!".match(/\bJava\b/) ); // null
```

对 `"Hello, Java!"` 的边界匹配：

```JavaScript
alert( "Hello, Java!".match(/\bHello\b/) ); // Hello
alert( "Hello, Java!".match(/\bJava\b/) );  // Java
alert( "Hello, Java!".match(/\bHell\b/) );  // null (no match)
alert( "Hello, Java!".match(/\bJava!\b/) ); // null (no match)
```

## 转义，特殊字符

所有特殊字符的列表：`[ \ ^ $ . | ? * + ( )`

如果要把特殊字符作为常规字符来使用，需要在它前面加个反斜杠进行转义

```JavaScript
alert( "Chapter 5.1".match(/\d\.\d/) ); // 5.1
```

除了特殊字符，正斜杠也需要转移，因为它是正则表达式边界

使用 `new RegExp` 创建正则实例时需要多加一层转义

例如

```JavaScript
let reg = new RegExp("\d\.\d");

alert( "Chapter 5.1".match(reg) ); // null
```

在字符串中的反斜杠表示转义或者类似 `\n` 这种只能在字符串中使用的特殊字符，所以这里的字符串 `reg` 被转义成了 `d.d`

要修复问题则多加一个斜杠

```JavaScript
let regStr = "\\d\\.\\d";
alert(regStr); // \d\.\d

let regexp = new RegExp(regStr);
alert( "Chapter 5.1".match(regexp) ); // 5.1
```

## 集合和范围 `[...]`

方括号 `[...]` 中的几个字符或者字符类：搜索给定的字符中的任意一个

**集合**

```JavaScript
// 查找 V，然后匹配 [o 或者 i]，之后再匹配 la
alert( "Voila".match(/V[oi]la/) ); // null，并没有匹配上

// 查找 [t 或者 m]，然后再匹配 op
alert( "Mop top".match(/[tm]op/gi) ); // "Mop", "top"
```

除了在方括号中有特殊含义的字符外，其它所有特殊字符都是允许不添加反斜杠的，加了也不会出问题

如果在方括号中出现了代理对，那么需要加上符号 `u`，保证不出差

**范围**

方括号也可以包含字符范围

比如说，`[a-z]` 会匹配从 `a` 到 `z` 范围内的字母，`[0-5]` 表示从 `0` 到 `5` 的数字

示例：

```JavaScript
alert( "Exception 0xAF".match(/x[0-9A-F][0-9A-F]/g) ); // xAF
```

首先匹配 `"x"` 字符，再匹配两个数字或者位于 `A` 到 `F` 范围内的字符

字符类是某些字符集的简写，比如 `\d` 和 `[0-9]` 相同

**多语言 `\w`**

字符类 `\w` 是简写的 `[a-zA-Z0-9_]`，因此无法找到中文象形文字，西里尔字母，更通用的模式为 `Unicode` 属性

```JavaScript
let regexp = /[\p{Alpha}\p{M}\p{Nd}\p{Pc}\p{Join_C}]/gu;
let str = `Hi 你好 12`;

alert( str.match(regexp) ); // H,i,你,好,1,2
```

**排除范围**

`[^...]` 表示匹配所有除了给定的字符之外的**任意字符**

```JavaScript
alert( "alice15@gmail.com".match(/[^\d\sA-Z]/gi) ); // @ and .
```

注意，必须包含字符

```JavaScript
alert( "Java".match(/Java[^script]/) ); // null
```

## 量词 `+,*,?` 和 `{n}`

在一个字符（或一个字符类等等）后跟着一个量词，用来指出我们具体需要的数量

- 确切位数：`{5}`

- 位数范围：`{3,5}`

  可以省略上限，`{3,}` 表示位数大于等于 `3`

**缩写**

- `+`：`{1,}` - `1` 个或多个
- `?`：`{0,1}` - `0` 个或 `1` 个
- `*`：`{0,}` - `0` 个或多个

## 贪婪量词和惰性量词

看个例子

```JavaScript
let reg = /".+"/g;
let str = 'a "witch" and her "broom" is one';

alert( str.match(reg) ); // "witch" and her "broom"
```

我们只想匹配单个引号引起来的单词，但它将最长的返回了，这就叫**贪婪**

算法大致过程：

1. 匹配 `"`
2. 匹配 `.+`：因为之后的全部符合这个式子，所以会匹配到末尾
3. 匹配 `"`：因为此时已在末尾，所以会**回溯**

最后就得到了上面的结果

**懒惰模式**

与贪婪模式相对，懒惰模式**重复最少次数**

开启方式：在一个**量词**后添加 `?` 符号

```JavaScript
let reg = /".+?"/g;
let str = 'a "witch" and her "broom" is one';

alert( str.match(reg) ); // witch, broom
```

现在符合预期，现在的算法过程如下：

- 匹配 `"`
- 匹配 `.+?`：因为是重复最少次数，所以匹配到 `w` 就停止
- 匹配 `"`：如果没匹配到，继续下一个，知道匹配到 `"`

也就是：只有在模式的剩余部分无法在给定位置匹配时，正则表达式引擎才会增加重复次数

懒惰模式只能够通过带 `?` 的量词启用，其他量词依旧是贪婪模式

```JavaScript
alert( "123 456".match(/\d+ \d+?/g) ); // 123 4
```

**替代方法**

`"[^"]+"` 与懒惰模式看似运行结果差不多，但是也有区别

`"[^"]+"` 严格匹配**最近**的两个**之间没有引号**的引号

懒惰模式匹配符合要求的，但可能不合常理

例如

```JavaScript
let str = '...<a href="link1" class="wrong">... <p style="" class="doc">...';
let reg = /<a href=".*?" class="doc">/g;

// 错误！
alert( str.match(reg) ); // <a href="link1" class="wrong">... <p style="" class="doc">
```

这里的懒惰模式需要匹配到 `class="doc"`，但是最近的在 `p` 标签中，所以会匹配整个字符串

这显然不是预期的情况，这里应该使用 `"[^"]*"`

```JavaScript
let str = '...<a href="link1" class="wrong">... <p style="" class="doc">...';
let reg = /<a href="[^"]*" class="doc">/g;

alert( str.match(reg) ); // 没有匹配项，这才是正确答案
```
