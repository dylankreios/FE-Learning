## try...catch

**`try...catch` 语法**

```JavaScript
try {
  // 代码...
} catch (err) {
  // 错误捕获
}
```

执行顺序：

1. 执行 `try {...}` 中的代码
2. 如果这里没有错误，则忽略 `catch(err)`
3. 如果这里出现错误，则 `try` 执行停止，跳转到 `catch(err)` 的开头。变量 `err` 将包含一个 `error` 对象，包含了所发生事件的详细信息

`try...catch` 本身的错误叫解析错误，无法处理，`try` 内部的错误叫运行时错误，才能被正确处理

`try...catch` 只能捕获同步的错误，异步错误不能捕获

```JavaScript
try {
  setTimeout(function() {
    noSuchVariable; // 这里有错
  }, 1000);
} catch (e) {
  console.log( "won't work" );
}
```

**Error 对象**

内建 `Error` 对象的属性

主要属性

- `name`：`Error` 名称，例：`ReferenceError`
- `message`：关于 `error` 的详细文字描述

非标准属性

- `stack`：当前的调用栈

```JavaScript
try {
  lalala; // error
} catch(err) {
  console.log(err.name); // ReferenceError
  console.log(err.message); // lalala is not defined
  console.log(err.stack); // ReferenceError: lalala is not defined at (...call stack)

  console.log(err); // ReferenceError: lalala is not defined
}
```

`error` 是可选的

```JavaScript
try {
  // ...
} catch {
  // ...
}
```

实例：解析服务器的数据

如果 `json` 格式错误，`JSON.parse` 就会生成一个 `error`

```JavaScript
let json = "{ bad json }";

try {
  let user = JSON.parse(json); // 出现 error
  console.log( user.name ); // 不工作
} catch (e) {
  // 跳转到这里并继续执行
  console.log( "the data has errors" );
  console.log( e.name );
  console.log( e.message );
}
```

## 抛出自定义 `error`

使用 `throw` 操作符抛出错误，`throw` 操作符后可跟任何东西，但一般是对象，并具有 `name` 和 `message`

内建错误构造器

- `Error`
- `SyntaxError`
- `ReferenceError`
- `TypeError` 等

```JavaScript
let error = new Error(message);
let error = new SyntaxError(message);
let error = new ReferenceError(message);
```

错误的 `name` 就是构造器的名字，错误的 `message` 是传入的字符串

对上面代码，如果 `json` 数据没有我们想要的 `name` 属性，则抛出错误

```JavaScript
let json = '{ "age": 30 }'; // 不完整的数据

try {
  let user = JSON.parse(json); // 没有 error
  if (!user.name) {
    throw new SyntaxError("Incomplete data: no name");
  }
  console.log( user.name );
} catch(e) {
  console.log( "JSON Error: " + e.message ); // JSON Error: Incomplete data: no name
}
```

**再次抛出**

`catch` 应该只处理它知道的 `error`，并抛出所有其他 `error`

```JavaScript
let json = '{ "age": 30 }'; // 不完整的数据
try {
  let user = JSON.parse(json);
  if (!user.name) {
    throw new SyntaxError("Incomplete data: no name");
  }
  blabla(); // 预料之外的 error
  console.log( user.name );
} catch(e) {
  if (e instanceof SyntaxError) {
    console.log( "JSON Error: " + e.message );
  } else {
    throw e; // 再次抛出
  }
}
```

这里 `catch` 只处理 `SyntaxError` 类型的错误，其他错误会被抛出，也许会被再外面所捕获

```JavaScript
function readData() {
  let json = '{ "age": 30 }';
  try {
    blabla(); // error
  } catch (e) {
    if (!(e instanceof SyntaxError)) {
      throw e; // 再次抛出（不知道如何处理它）
    }
  }
}

try {
  readData();
} catch (e) {
  alert( "External catch got: " + e ); // 捕获了它！
}
```

**try...catch...finally**

语法

```JavaScript
try {
   ... 尝试执行的代码 ...
} catch(e) {
   ... 处理 error ...
} finally {
   ... 总是会执行的代码 ...
}
```

适用场景

当我们开始做某事的时候，希望无论出现什么情况都要完成完成某个任务

一个函数中返回不是立即停止的例子，一旦进入 `try`，必须执行完

```JavaScript
function func() {
  try {
    return 1;
  } catch (e) {
  } finally {
    console.log( 'finally' );
  }
}

console.log( func() ); // 先执行 finally 中的 log，然后执行这个 log
```

`catch` 语段也可以去除，即不处理错误，但在出错后不立即停止，而是再执行一段

**全局 `catch`**

用于在发生未捕获的 error 时执行

- `Node.js`：`process.on("uncaughtException")`

- `Browser`：`window.onerror`

语法

```JavaScript
/**
 * message: Error 信息
 * url：发生 error 的脚本的 URL
 * line，col：发生 error 处的代码的行号和列号
 * error：Error 对象
 */
window.onerror = function(message, url, line, col, error) {};
```

示例

```JavaScript
  window.onerror = function(message, url, line, col, error) {
    console.log(`${message}\n At ${line}:${col} of ${url}`);
  };

  function readData() {
    badFunc(); // 出问题了
  }

  readData();
```

## 自定义 Error，扩展 Error
